<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: PlistParser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: PlistParser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Todo: Compare with https://github.com/chobie/php-plist/blob/master/plist.php
// Todo: Handle comments within as per the above?
// Todo: Support optional date parsing

/** @module PlistParser */

class PlistParser {
  /**
  * @param {object} cfg
  * @param {string} cfg.plist
  * @param {boolean} cfg.hexAsArrays
  * @param {boolean} cfg.allowAngledBracketStrings
  * @param {boolean} cfg.allowUnquotedStringsAtRoot
  * @param {boolean} cfg.allowMissingSeparators
  */
  constructor ({plist, hexAsArrays, allowAngledBracketStrings, allowUnquotedStringsAtRoot, allowMissingSeparators}) {
    this.i = 0;
    this.currentParents = [];
    Object.assign(this, {plist, hexAsArrays, allowAngledBracketStrings, allowUnquotedStringsAtRoot, allowMissingSeparators});
  }
  /**
  * @returns {DefaultsResult}
  */
  start () {
    this.check();
    return this.output;
  }
  /**
  * @returns {string} The next non-whitespace character or the current one if it is non-whitespace
  */
  advanceWhitespace () {
    let ch = this.plist[this.i];
    while (ch &amp;&amp; (/\s/).test(ch)) {
      ch = this.plist[++this.i];
    }
    return ch;
  }
  /**
  * @throws {Error}
  * @returns {object|Array} The current parent object or array
  */
  getCurrentParent () {
    if (!this.currentParents.length) {
      throw new Error('Unexpected parsing state: no current parent found');
    }
    return this.currentParents[this.currentParents.length - 1][0];
  }
  /**
  * @throws {Error}
  * @returns {Integer} The integer count of how many items have so far been found in the current parent object or array
  */
  getCurrentParentItemCount () {
    if (!this.currentParents.length) {
      throw new Error('Unexpected parsing state: no current parent found');
    }
    return this.currentParents[this.currentParents.length - 1][1];
  }
  /**
  * Increment the count of how many items have been found in the current parent object or array
  */
  incrementCurrentParentItemCount () {
    this.currentParents[this.currentParents.length - 1][1] =
    (this.getCurrentParentItemCount()) + 1;
  }
  /**
  * @param {"array"|"dict"} mode
  * @throws {TypeError}
  */
  checkParentItemCount (mode) {
    if (this.allowMissingSeparators) {
      return;
    }
    const count = this.getCurrentParentItemCount();
    switch (mode) {
    case 'array': {
      const len = this.getCurrentParent().length;
      // console.log('len1', len, count);
      if (count &lt; len) {
        throw new TypeError('Missing comma between array items');
      }
      break;
    }
    case 'dict': {
      const len = Object.keys(this.getCurrentParent()).length;
      // console.log('len2', len, count);
      if (count &lt; len) {
        throw new TypeError('Missing semi-colon between dict items');
      }
    }
    }
  }

  /**
  * @returns {Array} An array of the mode ("firstRun"|"array"|"dict") and the current parent (or `null` if this is the first run)
  */
  getModeAndCurrentParent () {
    if (!this.currentParents.length) {
      return ['firstRun', null];
    }
    const lastObj = this.getCurrentParent();
    return [
      Array.isArray(lastObj)
        ? 'array'
        : 'dict',
      lastObj
    ];
  }
  /**
  * @todo Prevent odd count hex at non-root as will be ignored?
  * @throws {RangeError}
  * @throws {TypeError}
  * @returns {Array|Uint8Array}
  */
  data () {
    let ch = this.plist[this.i];
    const hex = [];

    let hexChr;
    while (ch &amp;&amp; (hexChr = (/\s|([\da-f])/i).exec(ch)) !== null) { // Deliberately case-insensitive
      if (hexChr[1]) {
        hex.push(parseInt(hexChr, 16));
      }
      ch = this.plist[++this.i];
    }
    if (!ch) {
      throw new RangeError('Premature end to data (hex)');
    }
    if (ch !== '>') {
      throw new TypeError('Invalid data (hex) end character: "' + ch + '" after hex string: ' + hex + ' ; offset: ' + this.i);
    }
    this.i++;
    return this.hexAsArrays ? hex : new Uint8Array(hex);
  }
  /**
  * @returns {object}
  */
  dict () {
    const obj = {};
    this.currentParents.push([obj, 0]);
    this.check();
    return obj;
  }
  /**
  * @returns {Array}
  */
  array () {
    const arr = [];
    this.currentParents.push([arr, 0]);
    this.check();
    return arr;
  }
  /**
  * @param {object} [cfg]
  * @param {boolean} [cfg.hexString]
  * @param {boolean} [cfg.allowUnquotedStringsAtRoot]
  * @throws {RangeError}
  * @throws {TypeError}
  * @returns {string}
  * Output generated by `ioreg -rd1 -c IOPlatformExpertDevice`
  *   seems to allow `&lt;"...">` formatted strings;
  *   see `string()` callers below
  */
  string ({hexString, allowUnquotedStringsAtRoot} = {}) {
    let str = '';
    let ch = this.plist[this.i];
    const startQuote = ch === '"' || ch === "'"
      ? ch
      : '';

    if (startQuote || allowUnquotedStringsAtRoot) {
      const noStartQuote = allowUnquotedStringsAtRoot &amp;&amp; !startQuote;
      let ch = this.plist[noStartQuote ? this.i : ++this.i];
      while (true) { // eslint-disable-line no-constant-condition
        if (!ch) {
          if (noStartQuote) {
            break;
          }
          throw new RangeError('Unexpected end of quoted string at offset ' + this.i);
        }
        if (ch === startQuote) {
          break;
        }
        if (ch === '\\') {
          ch = this.plist[++this.i];
          if (!ch) {
            throw new RangeError('Unexpected end of quoted string (after backslash) at offset ' + this.i);
          }
          // Format gives double backslashes (e.g., to escape quotes) so we
          //   look for another to swallow it
          if (ch === '\\') {
            ch = this.plist[++this.i];
          } else if (ch !== startQuote) {
            str += '\\';
          }
          // Now advanced past escaped quote so safe for loop to resume and break on next (unescaped) `startQuote`
        }
        str += ch;
        ch = this.plist[++this.i];
      }
    } else {
      while (ch &amp;&amp; (/\w/).test(ch)) {
        str += ch;
        ch = this.plist[++this.i];
      }
    }
    if (startQuote) {
      ch = this.plist[++this.i];
      if (this.allowAngledBracketStrings &amp;&amp; hexString) {
        if (!ch) {
          throw new RangeError(
            'Premature end to angled bracket string (no closing bracket)'
          );
        }
        if (ch !== '>') {
          throw new TypeError('Angled bracket string closing bracket expected but found ' + ch);
        }
        this.i++;
      }
    }
    return str;
  }
  /**
  * @param {object} [cfg]
  * @param {boolean} [cfg.dictValue]
  * @throws {RangeError}
  * @throws {TypeError}
  * @returns {undefined|DefaultsResult}
  */
  check ({dictValue} = {}) {
    let ch = this.advanceWhitespace();
    let result;
    let currentKey;
    const [mode, currentParent] = dictValue
      ? ['firstRun', null]
      : this.getModeAndCurrentParent();
    switch (ch) {
    case undefined: {
      if (mode === 'firstRun') {
        throw new RangeError('No non-whitespace input found at offset ' + this.i);
      }
      return; // Finished!
    }
    case '{': {
      this.i++;
      result = this.dict();
      break;
    }
    case '(': {
      this.i++;
      result = this.array();
      break;
    }
    case '&lt;': {
      ch = this.plist[++this.i];
      if (this.allowAngledBracketStrings &amp;&amp; ch === '"') {
        result = this.string({hexString: true});
      } else {
        result = this.data();
      }
      break;
    }
    case '}': {
      if (mode !== 'dict') {
        throw new TypeError('Unexpected close for dict at offset ' + this.i);
      }
      this.i++;
      this.currentParents.pop();
      return;
    }
    case ')': {
      if (mode !== 'array') {
        throw new TypeError('Unexpected close for array at offset ' + this.i);
      }
      this.i++;
      this.currentParents.pop();
      return;
    }
    case ',': {
      if (mode !== 'array') {
        throw new TypeError('Unexpected comma during non-array mode ' + mode + '; at index ' + this.i);
      }
      this.i++;
      this.incrementCurrentParentItemCount();
      this.check();
      // Todo: Should we throw upon repeating ','?
      return;
    }
    case ';': {
      if (mode !== 'dict') {
        throw new TypeError('Unexpected semi-colon during non-dict mode ' + mode + '; at index ' + this.i);
      }
      this.i++;
      this.incrementCurrentParentItemCount();
      ch = this.advanceWhitespace();
      if (!ch) {
        throw new RangeError(
          'Premature end to dict (after semi-colon)'
        );
      }
      this.check();
      // Todo: Should we throw upon repeating ';'?
      return;
    }
    default:
      switch (mode) {
      case 'array': {
        result = this.string();
        break;
      }
      case 'dict': {
        currentKey = this.string();
        ch = this.advanceWhitespace();
        if (!ch) {
          throw new RangeError('Premature end to dict (before equals)');
        }
        if (ch !== '=') {
          throw new TypeError(
            'Expecting "=" character after dict key ' + (currentKey === '') +
            '; found ' + ch + '; at offset ' + this.i + '; ' // + this.plist.slice(this.i)
          );
        }
        this.i++;
        ch = this.advanceWhitespace();
        if (!ch) {
          throw new RangeError('Premature end to dict (after equals)');
        }
        result = this.check({dictValue: true});
        ch = this.advanceWhitespace();
        if (!ch) {
          throw new RangeError(
            'Premature end to dict (before semi-colon)'
          );
        }
        break;
      }
      default: { // "firstRun"
        result = this.string({allowUnquotedStringsAtRoot: !dictValue &amp;&amp; this.allowUnquotedStringsAtRoot});
        break;
      }
      }
      break;
    }

    switch (mode) {
    case 'firstRun': {
      this.output = result;
      ch = this.advanceWhitespace();

      if (!dictValue) {
        if (ch) {
          throw new TypeError(
            'Unexpected character ' + ch +
            ' after root processed on first run (' +
            'at index: ' + this.i + '); root: ' + JSON.stringify(result)
          );
        }
        // Retrieve mode again
        const [mode] = this.getModeAndCurrentParent();
        switch (mode) {
        case 'array': {
          throw new RangeError('Premature end to array');
        }
        case 'dict': {
          throw new RangeError('Premature end to dict (before key)');
        }
        }
      }
      // Finished!
      return result;
    }
    case 'array': {
      this.checkParentItemCount(mode);
      currentParent.push(result);
      break;
    }
    case 'dict': {
      this.checkParentItemCount(mode);
      currentParent[currentKey] = result;
      break;
    }
    }
    this.check();
    return result;
  }
}

module.exports = PlistParser;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-getParsedIORegInfo.html">getParsedIORegInfo</a></li><li><a href="module-MacOSDefaults.html">MacOSDefaults</a></li><li><a href="module-PlistParser.html">PlistParser</a></li></ul><h3>Classes</h3><ul><li><a href="module-MacOSDefaults-MacOSDefaults.html">MacOSDefaults</a></li><li><a href="module-PlistParser-PlistParser.html">PlistParser</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Jun 26 2018 17:39:32 GMT+0800 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
